// let: 不存在变量提升，暂时性死区，不允许重复声明

// ---------------------------------------------------------------
{
  let a = 10;
  var b = 1;
}
// console.log(a);
console.log(b);

// 使用var变量进行循环
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10

// 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。
// 每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。
// 也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。

// 使用let变量进行循环
var a = [];
for (let i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6

// let声明的变量仅在块级作用域中有效，最后输出6
// 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，
// 所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
// 你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？
// 这是因为 JavaScript 引擎内部会记住上一轮循环的值，
// 初始化本轮的变量i时，就在上一轮循环的基础上进行计算。

// 另外，for循环还有一个特别之处，
// 就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
for (let i = 0; i < 3; i++) {
  let i = "abc";
  console.log(i);
}
// 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域
// （同一个作用域不可使用 let 重复声明同一个变量）。

// ---------------------------------------------------------------

// 暂时性死区
var tmp = 123;

if (true) {
  // TDZ开始
  // tmp = "abc"; // ReferenceError
  // console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}

// 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。
// ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
// 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。

// tips: “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。
// typeof x;
let x;

// ---------------------------------------------------------------

// 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数。
// function func1(arg) {
//   let arg;
// }
// func(); // 报错

function func2(arg) {
  {
    let arg;
  }
}
func2(); // 不报错
